(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{842:function(t,_,a){"use strict";a.r(_);var s=a(14),r=Object(s.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1、流水线执行的总时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、流水线执行的总时间"}},[t._v("#")]),t._v(" 1、流水线执行的总时间")]),t._v(" "),_("p",[t._v("流水线执行的总时间 = 第一条指令执行时间 + (n-1) * 最长段时间")]),t._v(" "),_("h2",{attrs:{id:"_2、加速比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、加速比"}},[t._v("#")]),t._v(" 2、加速比")]),t._v(" "),_("p",[t._v("加速比 = 不采用流水的Time / 采用流水线的Time")]),t._v(" "),_("h2",{attrs:{id:"_3、吞吐率"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、吞吐率"}},[t._v("#")]),t._v(" 3、吞吐率")]),t._v(" "),_("p",[t._v("n / (执行一条指令的时间 +(n-1)*最长时间段)\t【n指令数】")]),t._v(" "),_("ul",[_("li",[t._v("n：总指令数，即要执行的指令总量。")]),t._v(" "),_("li",[t._v('"执行一条指令的时间"：流水线开始后第一条指令所需的时间，这通常是流水线的初始化时间。')]),t._v(" "),_("li",[t._v('"(n-1) \\times \\text{最长时间段}"：后续指令的执行时间，其中“最长时间段”是流水线中所有阶段中最长的执行时间，这一部分反映了流水线中各个阶段的并行处理效率。')])]),t._v(" "),_("p",[t._v("备注：这个公式计算的是流水线的吞吐率，表示单位时间内可以完成的指令数量。它有助于评估流水线设计的效率，帮助工程师理解在特定条件下性能的提升。通过分析吞吐率，开发者可以优化系统，提升整体执行效率。")]),t._v(" "),_("h2",{attrs:{id:"_4、操作周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、操作周期"}},[t._v("#")]),t._v(" 4、操作周期")]),t._v(" "),_("p",[t._v("操作周期就是流程中最长的操作时间")])])}),[],!1,null,null,null);_.default=r.exports}}]);